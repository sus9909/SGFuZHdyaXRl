<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwriting Generation API</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: center;
        }
        .loading {
            background: #fff3cd;
            color: #856404;
        }
        .ready {
            background: #d4edda;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
        }
        #canvas {
            display: none;
        }
        .api-info {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>✍️ Handwriting Generation API</h1>
        
        <div id="status" class="status loading">
            <div id="loading-indicator">Loading model...</div>
        </div>

        <svg id="canvas" width="1240" height="200" xmlns="http://www.w3.org/2000/svg"></svg>
        
        <div class="api-info">
            <h2>API Usage</h2>
            <p>This is a static API that generates handwriting using the original JavaScript model.</p>
            
            <h3>POST Request</h3>
            <p>Send a POST request with JSON body:</p>
            <pre>{
  "text": "Your text here",
  "style": "5",
  "bias": "0.5",
  "speed": "1",
  "width": "1"
}</pre>
            
            <h3>Response</h3>
            <p>Returns JSON with base64 encoded PNG:</p>
            <pre>{
  "success": true,
  "image": "base64_encoded_png_data",
  "format": "png"
}</pre>
            
            <h3>Example (JavaScript)</h3>
            <pre>const response = await fetch('https://your-username.github.io/api/', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    text: 'Hello World',
    style: '5',
    bias: '0.5',
    speed: '1',
    width: '1'
  })
});

const data = await response.json();
// data.image contains base64 PNG</pre>
        </div>
    </div>

    <!-- Hidden elements for the original script -->
    <input type="hidden" id="text-input" value="">
    <input type="hidden" id="select-style" value="-">
    <input type="hidden" id="bias-slider" value="0.5">
    <input type="hidden" id="speed-slider" value="1">
    <input type="hidden" id="width-slider" value="1">
    <button id="draw-button" style="display:none;"></button>
    <button id="save-button" style="display:none;"></button>

    <script>
        // Override the d.bin path before loading logic.js
        // This fixes the hardcoded "/d.bin" path in logic.js
        (function() {
            const originalFetch = window.fetch;
            window.fetch = function(url, options) {
                // Redirect /d.bin requests to the correct path
                if (url === '/d.bin' || url.endsWith('/d.bin')) {
                    // Get the base path of current page
                    const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
                    url = basePath + 'd.bin';
                }
                return originalFetch(url, options);
            };
        })();
    </script>
    <script src="logic.js"></script>
    <script>
        let modelReady = false;
        let currentGeneration = null;

        // Override the original E function to work with our API
        const originalE = E;
        window.generateHandwriting = async function(text, style = '-', bias = '0.5', speed = '1', width = '1') {
            return new Promise((resolve, reject) => {
                try {
                    // Set parameters
                    document.getElementById('text-input').value = text;
                    document.getElementById('select-style').value = style;
                    document.getElementById('bias-slider').value = bias;
                    document.getElementById('speed-slider').value = speed;
                    document.getElementById('width-slider').value = width;

                    // Clear canvas
                    const canvas = document.getElementById('canvas');
                    while (canvas.lastChild) {
                        canvas.removeChild(canvas.lastChild);
                    }

                    // Start generation
                    originalE();

                    // Wait for completion and convert to PNG
                    setTimeout(() => {
                        try {
                            const svgElement = document.getElementById('canvas');
                            const bbox = svgElement.getBBox();
                            
                            // Set viewBox for proper cropping
                            const viewBox = [
                                (bbox.x - 3).toFixed(3),
                                (bbox.y - 3).toFixed(3),
                                (bbox.width + 6).toFixed(3),
                                (bbox.height + 6).toFixed(3)
                            ].join(' ');
                            svgElement.setAttribute('viewBox', viewBox);
                            
                            // Serialize SVG
                            const serializer = new XMLSerializer();
                            const svgString = serializer.serializeToString(svgElement);
                            
                            // Convert SVG to PNG using canvas
                            const img = new Image();
                            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                            const url = URL.createObjectURL(svgBlob);
                            
                            img.onload = function() {
                                const canvas = document.createElement('canvas');
                                canvas.width = bbox.width + 6;
                                canvas.height = bbox.height + 6;
                                const ctx = canvas.getContext('2d');
                                
                                // White background
                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Draw image
                                ctx.drawImage(img, 0, 0);
                                
                                // Get base64 PNG
                                const pngBase64 = canvas.toDataURL('image/png').split(',')[1];
                                
                                URL.revokeObjectURL(url);
                                svgElement.removeAttribute('viewBox');
                                
                                resolve(pngBase64);
                            };
                            
                            img.onerror = function() {
                                URL.revokeObjectURL(url);
                                reject(new Error('Failed to convert SVG to PNG'));
                            };
                            
                            img.src = url;
                            
                        } catch (error) {
                            reject(error);
                        }
                    }, 3000); // Wait 3 seconds for generation to complete
                    
                } catch (error) {
                    reject(error);
                }
            });
        };

        // Wait for model to load
        const checkModelReady = setInterval(() => {
            if (typeof $ !== 'undefined' && $.g) {
                modelReady = true;
                clearInterval(checkModelReady);
                document.getElementById('status').className = 'status ready';
                document.getElementById('loading-indicator').textContent = '✓ API Ready - Model Loaded';
                
                // Set up API endpoint handler
                setupAPIHandler();
            }
        }, 100);

        function setupAPIHandler() {
            // Handle incoming requests via postMessage (for iframe communication)
            window.addEventListener('message', async (event) => {
                if (event.data.action === 'generate') {
                    try {
                        const { text, style, bias, speed, width } = event.data;
                        const imageBase64 = await window.generateHandwriting(
                            text,
                            style || '-',
                            bias || '0.5',
                            speed || '1',
                            width || '1'
                        );
                        
                        event.source.postMessage({
                            success: true,
                            image: imageBase64,
                            format: 'png'
                        }, event.origin);
                    } catch (error) {
                        event.source.postMessage({
                            success: false,
                            error: error.message
                        }, event.origin);
                    }
                }
            });

            // Handle direct API calls via URL parameters (for testing)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('text')) {
                const text = urlParams.get('text');
                const style = urlParams.get('style') || '-';
                const bias = urlParams.get('bias') || '0.5';
                const speed = urlParams.get('speed') || '1';
                const width = urlParams.get('width') || '1';
                
                window.generateHandwriting(text, style, bias, speed, width)
                    .then(imageBase64 => {
                        // Display result
                        const resultDiv = document.createElement('div');
                        resultDiv.innerHTML = `
                            <h3>Generated Image</h3>
                            <img src="data:image/png;base64,${imageBase64}" style="max-width: 100%; border: 1px solid #ddd; border-radius: 5px; margin-top: 10px;">
                            <p style="margin-top: 10px; font-size: 12px; color: #666;">
                                <a href="data:image/png;base64,${imageBase64}" download="handwriting.png">Download PNG</a>
                            </p>
                        `;
                        document.querySelector('.container').appendChild(resultDiv);
                    })
                    .catch(error => {
                        document.getElementById('status').className = 'status error';
                        document.getElementById('loading-indicator').textContent = 'Error: ' + error.message;
                    });
            }
        }

        // Expose API endpoint via fetch interception (Service Worker would be needed for true REST API)
        // For now, we'll use a simple approach where the Python bot can make requests via a hidden iframe
        window.apiGenerate = async function(params) {
            if (!modelReady) {
                throw new Error('Model not ready');
            }
            
            const imageBase64 = await window.generateHandwriting(
                params.text,
                params.style || '-',
                params.bias || '0.5',
                params.speed || '1',
                params.width || '1'
            );
            
            return {
                success: true,
                image: imageBase64,
                format: 'png'
            };
        };

        // Timeout warning
        setTimeout(() => {
            if (!modelReady) {
                document.getElementById('status').className = 'status error';
                document.getElementById('loading-indicator').textContent = '⚠ Model loading timed out. Please refresh the page.';
            }
        }, 30000);
    </script>
</body>
</html>
